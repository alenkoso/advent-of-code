I built a solution that tackles a complex digital circuit puzzle - you know, those logic gates from Computer Architecture at UL FRI? The first part was pretty straightforward; I needed to simulate how signals flow through AND, OR, and XOR gates, kind of like tracing electricity through a circuit. After fighting with a few infinite propagation loops and accidentally creating some circular dependencies (oopsie), I implemented a simulation that handles all the gate dependencies correctly.

Part two is where things got interesting. I needed to identify critical gates that could cause signal errors, but checking every possible combination would've been taken forever, trust me, I know, been there, quite a few times. My first few attempts got completely stuck trying to brute force the solution - I even managed to crash Python with a stack overflow at one point. 
Instead, I implemented a targeted analysis that looks for specific patterns in the circuit structure. The code examines gates in three stages (input, intermediate, and output gates) and flags any irregularities in the expected pattern of XOR gates for binary addition and OR gates for carry propagation. Those lectures about full adder circuits really came in handy here, though it took me a while to realize I was essentially dealing with a modified version of one!

The main challenge was figuring out how to programmatically detect these problematic gates without having to eyeball the circuit. 
I actually solved part 2 by hand first - mapping out the circuit on paper and finding the faulty gates manually. But I knew there had to be a way to automate this, and I don't like leaving problems half-solved. 
After several failed attempts at graph traversal algorithms and a particularly messy attempt at backtracking that I'd rather forget about, I ended up encoding my knowledge of how a proper binary adder circuit should behave and then systematically checking for deviations from this pattern. Using Python's handy set operations and list comprehensions kept the code clean while tracking all those wire connections and gate types. 
Not gonna lie, handling the edge cases at the start and end of the addition chain was a bit of a brain teaser - especially that sneaky bug where I kept getting false positives from improperly terminated carry chains. But the solution ended up being much more efficient than my earlier attempts at brute forcing it.